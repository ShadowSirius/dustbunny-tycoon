#summary The algorithm we are simulating

= Application Specification =

Applications using the network must have the following characteristics:

 * Delay tolerant
 * Loss tolerant
 * Relatively limited packet size (say 64-256 kb)
 * Independent packets - ie no segmentation and reassembly OR use of fountain/erasure ECCs (ex. [http://en.wikipedia.org/wiki/Raptor_code raptor codes])

= Information From Sources =

 * We are dealing with task-oriented mobility in ferries (defn from [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery] - this sources deals with message oriented mobility)
 * I was originally considering a scheme where nodes cluster and 'gateway nodes' (not to be confused with the gateway nodes as defined in the network entities section below) are responsible for communicating with ferries (terminology from section 6 of [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery]). This would come in stage 2 (if at all)

== Existing Algorithms ==

 * MANET protocols (DSDV, OSLR, AODV, DSR) only work for connected subgraphs (from [http://portal.acm.org/citation.cfm?id=1015484&dl=GUIDE&coll=GUIDE&CFID=82345016&CFTOKEN=82922258 Routing in a delay tolerant network])

= Our Project  =

== General Premise ==

The network contains numerous uniquely identifiable source nodes. Each source node supports a limited number of properties (in the form of key/value pairs). The network is designed to synchronize a central repository with the current key/value pair for every source node.

== Network ==

=== Network Entities ===

Terminology specific to this project.

*Message*: Contains data which updates the value associated with a source node, key pair. 

*Source Node* (Abbreviated src): Nodes which generate messages to be delivered to gateways. A message from any source can be delivered to any gateway.

*Message Ferry* (Abbreviated  mf): Mobile transport mechanisms for messages. Provided a delayed link to transport messages from source nodes to destination gateways.

*Gateway*: The destination for messages. Idea is that gateways connect to the internet. Once messages reach a gateway, they are routed through the internet to their final destination. *No source-source communication* (at least initially) 

=== Network Topology - For Simulation  ===

 * Source nodes and gateways distributed randomly and evenly (#src nodes >> #gateway nodes)
 * Multiple ferries with random trajectories

== General Algorithms Considerations ==

 * Packet timeout (from [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery])
 * Use location aware partitions and ferries? - Probably not initially. I dont think it is needed unless we do src->src communication.
 * Are we implementing a routing algorithm or a simpler delivery algorithm
   * Routing can either be 'source routing' or 'per-hop' routing (from [http://portal.acm.org/citation.cfm?id=1015484&dl=GUIDE&coll=GUIDE&CFID=82345016&CFTOKEN=82922258 Routing in a delay tolerant network])
   * Note that src->src or gateway->src requires routing and that src->gateway does not
   * _Probably just implement message delivery initially_
 * Do source nodes store messages for inter-ferry transfer (ie message path: src1 -> mf1 -> src2 -> mf2 -> gateway) - *YES*
 * Do source nodes communicate with eachother (aka, clustering) (message path: src1 -> src2 -> mf1 -> gateway) - *NO* (much more complicated problem)
 * Source nodes should communicate directly with gateways if possible (message path: src -> gateway)

== Simplifications and Assumptions ==

 * All or nothing wireless links (ie no fading - either two nodes can transmit or they cant)

== Project Roadmap == 

There are a few stages to implementing and simulating our project. I am not sure how many we will get to (doing only the first will probably be sufficient). Each stage adds features from the last. The "->" shows message transmission.

 # *src->mf->gateway*: Basic implementation (includes src1->mf1->src2->mf2->gateway support)
 # *src->src->mf->gateway*: Add clustering. _Should_ be fairly simple if we assume a static source node configuration. This is where mesh networking gets added.
 # *gateway->mf->src*: Adds duplex communication. This is likely to be MUCH more complicated to do well (I cant see us getting here). A very simple implementation might be possible.

= Algorithm - Stage 1 =

Support for one way updates including:
 * src->mf->gateway
 * src1->mf1->src2->mf2->gateway

== Packets ==

Two types of packets

=== Update Packet ===

Sent by the source when the value for one of its keys gets updated.

Fields:
 * *Source ID*: Globally unique for each source node.
 * *Packet timestamp*: When the message was generated. Used for throwing away old packets. Note that this is NOT when the value was changed.
 * *Key*: What value is being updated by this packet. 
 * *Key update counter*: What is the version of the value in this packet. Increments each time the source modifies the value associated with the given key. If a ferry comes across two updates for a key (specific to a single source), it chooses to keep the newest value. Also used when gateway sends ack packets.
 * *Value*: The new value (associated with the key field). This is the payload - the data associated with the packet.

=== ACK Packet ===

Sent by the gateway when it receives a source update

Fields: 

== Behavior ==

=== Source Node - Sending an Update ===

When the application writes a new value for a given key:
 # Add one to the key update counter (for that key)
 # If possible send an update to a gateway directly
 # Wait for a message ferry to come in range
 # Create an update packet and send it to the ferry
 # Wait for another ferry
  # If the ferry is carrying an ACK, END
  # Else, create another update packet and send it to the ferry