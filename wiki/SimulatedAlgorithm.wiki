#summary The algorithm we are simulating

= Application Specification =

Applications using the network must have the following characteristics:

 * Delay tolerant
 * Loss tolerant
 * Relatively limited packet size (say 64-256 kb)
 * Independent packets - ie no segmentation and reassembly OR use of fountain/erasure ECCs (ex. [http://en.wikipedia.org/wiki/Raptor_code raptor codes])

= Information From Sources =

 * We are dealing with task-oriented mobility in ferries (defn from [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery] - this sources deals with message oriented mobility)
 * I was originally considering a scheme where nodes cluster and 'gateway nodes' (not to be confused with the gateway nodes as defined in the network entities section below) are responsible for communicating with ferries (terminology from section 6 of [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery]). This would come in stage 2 (if at all)

== Existing Algorithms ==

 * MANET protocols (DSDV, OSLR, AODV, DSR) only work for connected subgraphs (from [http://portal.acm.org/citation.cfm?id=1015484&dl=GUIDE&coll=GUIDE&CFID=82345016&CFTOKEN=82922258 Routing in a delay tolerant network])

= Our Project  =

== General Premise ==

The network contains numerous uniquely identifiable source nodes. Each source node supports a limited number of properties (in the form of key/value pairs). The network is designed to synchronize a central repository with the current key/value pair for every source node.

== Network ==

=== Network Entities ===

*Message*: Contains data which updates the value associated with a source node, key pair. 

*Source Node* (Abbreviated src): Nodes which generate messages to be delivered to gateways. A message from any source can be delivered to any gateway.

*Message Ferry* (Abbreviated  mf): Mobile transport mechanisms for messages. Provided a delayed link to transport messages from source nodes to destination gateways.

*Gateway*: The destination for messages. Idea is that gateways connect to the internet. Once messages reach a gateway, they are routed through the internet to their final destination. *No source-source communication* (at least initially) 

=== Network Topology - For Simulation  ===

 * Source nodes and gateways distributed randomly and evenly (#src nodes >> #gateway nodes)
 * Multiple ferries with random trajectories

== General Algorithms Considerations ==

 * Packet timeout (from [http://portal.acm.org/citation.cfm?id=989483 Message ferrying approach for data delivery])
 * Use location aware partitions and ferries? - Probably not initially. I dont think it is needed unless we do src->src communication.
 * Are we implementing a routing algorithm or a simpler delivery algorithm
   * Routing can either be 'source routing' or 'per-hop' routing (from [http://portal.acm.org/citation.cfm?id=1015484&dl=GUIDE&coll=GUIDE&CFID=82345016&CFTOKEN=82922258 Routing in a delay tolerant network])
   * _Probably just implement message delivery initially_
 * Do source nodes store messages for inter-ferry transfer (ie message path: src1 -> mf1 -> src2 -> mf2 -> gateway) - *YES*
 * Do source nodes communicate with eachother (aka, clustering) (message path: src1 -> src2 -> mf1 -> gateway) - *NO* (much more complicated problem)
 * Source nodes should communicate directly with gateways if possible (message path: src -> gateway)

== Simplifications and Assumptions ==

 * All or nothing wireless links (ie no fading - either two nodes can transmit or they cant)

== Project Roadmap == 

There are a few stages to implementing and simulating our project. I am not sure how many we will get to (doing only the first will probably be sufficient). Each stage adds features from the last. The "->" shows message transmission 

 # *src->mf->gateway*: Basic implementation, includes src1->mf1->src2->mf2->gateway support 
 # *src->src->mf->gateway*: Add clustering. _Should_ be fairly simple if we assume a static source node configuration
 # *gateway->mf->src*: Adds duplex communication. This is likely to be MUCH more complicated (I cant see us getting here)

= Algorithm - Stage 1 =

Support for:
 * src->mf->gateway
 * src1->mf1->src2->mf2->gateway

== Packets ==

=== Source Update Packet ===

Sent by the source when the value for one of its keys gets updated.

Fields:
 * *Source ID*: 
 * *Timestamp*: When the message was generated
 * *Key*: What 
 * Key update counter (increments with each update by the source)